了解。**「実装容易性を最優先」**で、GAS側は**プレーンJavaScript（.gs/.js）**のみ、ビルド不要・型なし・最小ファイル構成。
**閲覧制限**は「**Next.js側でのGoogleログイン＋許可メールアドレスのホワイトリスト**」と「**GAS APIはサーバ側プロキシ経由のみ**（秘密キー必須）」の二段構えにします。
これで**外部からは直接GAS APIに触れず**、UIも**許可ユーザー以外は見られない**構成になります。

以下、**同じ形式**（設計仕様書 & 実装計画書）で再提示します。

---

# 0. 目的と前提（簡易版）

* **GAS（バックエンド）**：プレーンJSだけ。claspで管理・デプロイ。**ビルド工程なし**。

  * スプレッドシート（トリガー更新）を読み、**集約済みJSON**を返す**Web App**。
  * **API鍵（APP_TOKEN）必須**。これを**Nextのサーバルートだけが知る**（クライアントには渡さない）。
* **Next.js（フロント）**：Vercelで配信。**サーバルートがGAS APIをプロキシ**。

  * **Googleログイン**（Auth.js/NextAuth）＋**許可メールアドレスのallowlist**で**UI閲覧制限**。
  * ISR + SWRで高速&鮮度担保。
* **モノレポ**：pnpm Workspaces。最低限の共有ユーティリティのみ（型厳密化はしない）。

---

# 1. リポジトリ構成（モノレポ／ビルドなしGAS）

```txt
repo/
├─ pnpm-workspace.yaml
├─ package.json
├─ turbo.json                        # 任意（なくても可）
├─ .gitignore
├─ .env.example                      # Next用。GASはScript Properties
│
├─ apps/
│  ├─ web/                           # Next.js (App Router)
│  │  ├─ app/
│  │  │  ├─ (routes)/
│  │  │  │  ├─ dashboard/page.tsx
│  │  │  │  ├─ products/page.tsx
│  │  │  │  ├─ products/[sku]/page.tsx
│  │  │  │  └─ alerts/page.tsx
│  │  │  ├─ api/
│  │  │  │  ├─ gas/dashboard/route.ts    # ← GASを叩くサーバ側プロキシ
│  │  │  │  ├─ gas/products/route.ts
│  │  │  │  ├─ gas/product/[sku]/route.ts
│  │  │  │  └─ revalidate/route.ts
│  │  │  └─ layout.tsx
│  │  ├─ src/
│  │  │  ├─ lib/fetcher.ts            # クライアント→Nextサーバへのfetch
│  │  │  ├─ lib/auth.ts               # 許可メールallowlist
│  │  │  ├─ components/...
│  │  │  └─ hooks/useDashboard.ts
│  │  ├─ middleware.ts                # Googleログイン必須 & allowlistチェック
│  │  ├─ next.config.ts
│  │  ├─ package.json
│  │  ├─ tsconfig.json
│  │  └─ .env.local.example
│  │
│  └─ gas/                            # GAS（プレーンJS、ビルドなし）
│     ├─ src/
│     │  ├─ Code.js                   # doGet、ルーティング
│     │  ├─ router.js
│     │  ├─ handlers/
│     │  │  ├─ dashboard.js
│     │  │  ├─ products.js
│     │  │  ├─ product.js
│     │  │  └─ alerts.js
│     │  ├─ sheets.js                 # 読み出し & JOIN（商品状態の推奨発注/需要予測を含む）
│     │  └─ util.js                   # キャッシュ/JSON出力/安全な数値化
│     ├─ appsscript.json              # マニフェスト
│     ├─ .clasp.dev.json
│     ├─ .clasp.prod.json
│     └─ package.json                 # clasp用スクリプトのみ
│
└─ packages/
   └─ utils/                          # 共有ユーティリティ（任意／最小）
      ├─ src/index.ts
      ├─ package.json
      └─ tsconfig.json
```

> ポイント：**apps/gas は src のまま push**。esbuild/tscなし。

---

# 2. pnpm/turbo 設定

## `pnpm-workspace.yaml`

```yaml
packages:
  - "apps/*"
  - "packages/*"
```

## ルート `package.json`

```json
{
  "name": "amazon-seller-ui-monorepo",
  "private": true,
  "packageManager": "pnpm@9.0.0",
  "scripts": {
    "dev": "turbo run dev --parallel",
    "build": "turbo run build",
    "deploy:web": "pnpm -C apps/web vercel --prod",
    "deploy:gas:dev": "pnpm -C apps/gas deploy:dev",
    "deploy:gas:prod": "pnpm -C apps/gas deploy:prod"
  },
  "devDependencies": {
    "turbo": "^2.0.0"
  }
}
```

---

# 3. GAS（プレーンJS）仕様

## 公開・認証戦略（簡易＆強固）

* **Web App公開設定**：

  * 実行者：**自分（ユーザー）** or **アクセスしているユーザー**（どちらでも可）
  * アクセス権：**「全員（匿名含む）」**にしておく（※後述のAPI鍵が実質の壁）

    * 理由：Nextサーバ（Vercel）からの**サーバ側リクエスト**のみ通したい。
    * かわりに、**`?key=APP_TOKEN` が一致しない限り 401** を返し、**URLが漏れても外部は見られない**。
* **ユーザー制限**：

  * **UI側（Next）でGoogleログイン + allowlist**。
  * GASは**外部直叩き不可（鍵必須）**なので、**Nextサーバプロキシ経由の社内許可ユーザーだけ**が使える。

> Workspaceドメインをお持ちで「ドメイン内のみ」にしたい場合はWeb App側を**「ドメイン内ユーザーのみ」**にしてもOK。ただし**Nextサーバからの到達性**が落ちるため、基本は**鍵方式＋サーバプロキシ**が確実です。

## `apps/gas/package.json`

```json
{
  "name": "@app/gas",
  "private": true,
  "scripts": {
    "clasp:login": "clasp login",
    "use:dev": "cp .clasp.dev.json .clasp.json",
    "use:prod": "cp .clasp.prod.json .clasp.json",
    "push": "clasp push",
    "deploy:version": "clasp version 'deploy'",
    "deploy:webapp": "clasp deploy -d 'webapp'",
    "deploy:dev": "pnpm use:dev && pnpm push && pnpm deploy:version && pnpm deploy:webapp",
    "deploy:prod": "pnpm use:prod && pnpm push && pnpm deploy:version && pnpm deploy:webapp"
  },
  "devDependencies": {
    "@google/clasp": "^2.4.2"
  }
}
```

## `.clasp.*.json`

```json
{
  "scriptId": "AKfycbxxxxxxxxxxxxxxxxxxxxxxxx",
  "rootDir": "src"
}
```

## `appsscript.json`

```json
{
  "timeZone": "Asia/Tokyo",
  "exceptionLogging": "STACKDRIVER",
  "oauthScopes": [
    "https://www.googleapis.com/auth/spreadsheets.readonly"
  ],
  "runtimeVersion": "V8",
  "webapp": {
    "access": "ANYONE",          // ← 匿名可（鍵で制限）
    "executeAs": "USER_DEPLOYING"
  }
}
```

## コード（最小骨子／そのまま動く雛形）

### `src/Code.js`

```javascript
function doGet(e) {
  try {
    guard_(e); // ?key=APP_TOKEN チェック
    var p = (e && e.parameter && e.parameter.path) ? e.parameter.path.toLowerCase() : 'dashboard';
    if (p === 'dashboard') return handleDashboard_(e);
    if (p === 'products')  return handleProducts_(e);
    if (p === 'product')   return handleProductBySku_(e);
    if (p === 'alerts')    return handleAlerts_(e);
    return json_({ error: 'not found' }, 404);
  } catch (err) {
    return json_({ error: String(err) }, 500);
  }
}
```

### `src/util.js`

```javascript
function json_(obj, status) {
  // GASはステータス細かく返せないが、bodyに入れておく
  obj = obj || {};
  if (status) obj._status = status;
  return ContentService.createTextOutput(JSON.stringify(obj))
    .setMimeType(ContentService.MimeType.JSON);
}
function num_(v) { v = Number(v); return isNaN(v) ? 0 : v; }
function today_() { return Utilities.formatDate(new Date(), 'Asia/Tokyo', 'yyyy-MM-dd'); }
function cacheGet_(key) { return CacheService.getScriptCache().get(key); }
function cachePut_(key, value, seconds) { CacheService.getScriptCache().put(key, value, seconds || 60); }

function normalizeParams_(param) {
  var from = param.from || Utilities.formatDate(new Date(Date.now()-30*86400000), 'Asia/Tokyo', 'yyyy-MM-dd');
  var to   = param.to   || today_();
  var grain= (param.grain || 'day').toLowerCase();
  return { from: from, to: to, grain: grain, sku: param.sku || '' };
}
function guard_(e) {
  var token = e && e.parameter && e.parameter.key;
  var expected = PropertiesService.getScriptProperties().getProperty('APP_TOKEN');
  if (!expected || token !== expected) throw new Error('unauthorized');
}
```

### `src/sheets.js`（必要な範囲のみを読む／列名は実データに合わせる）

```javascript
var SS_ID = '<<YOUR_SHEET_ID>>';
var SH = {
  DAILY_SALES: '日次売上集計',
  SKU_SALES_DAILY: '商品別日次売上集計',
  BUYBOX_DAILY: 'カート取得率日次',
  STOCK_SKEW_DAILY: '商品別在庫日次集計',
  STOCK_GLOBAL_DAILY: '全体在庫日次集計',
  MASTER: '商品マスタ',
  STATE: '商品状態'
};

function open_() { return SpreadsheetApp.openById(SS_ID); }
function readAll_(sheetName) {
  var sh = open_().getSheetByName(sheetName);
  var values = sh.getDataRange().getValues();
  var head = values.shift();
  return values.map(function(row){
    var o = {};
    for (var i=0;i<head.length;i++) o[String(head[i])] = row[i];
    return o;
  });
}

function readDashboard_(from, to) {
  var sales = readAll_(SH.DAILY_SALES).filter(function(r){ return (r['売上日']>=from && r['売上日']<=to); });
  var res = {
    revenue: sales.reduce(function(a,r){ return a + num_(r['実質売上']); }, 0),
    orders:  sales.reduce(function(a,r){ return a + num_(r['注文件数']); }, 0),
    units:   sales.reduce(function(a,r){ return a + num_(r['出荷商品数']); }, 0)
  };
  var stockRows = readAll_(SH.STOCK_GLOBAL_DAILY).filter(function(r){ return r['日付']===to; });
  res.stockTotal = stockRows.length ? num_(stockRows[0]['在庫数']) : 0;

  var stateRows = readAll_(SH.STATE);
  res.recommendedOrderTotal = stateRows.reduce(function(a,r){ return a + num_(r['推奨発注数']); }, 0);
  res.demandForecastTotal   = stateRows.reduce(function(a,r){ return a + num_(r['需要予測']); }, 0);
  return res;
}

function joinMaster_(rowsBySku) {
  var master = readAll_(SH.MASTER);
  var bySku = {};
  master.forEach(function(r){ bySku[String(r['SKU'])] = r; });
  rowsBySku.forEach(function(x){
    var m = bySku[x.sku] || {};
    x.asin = m['ASIN'] || '';
    x.name = m['商品名'] || '';
    x.category = m['カテゴリ'] || '';
  });
  return rowsBySku;
}

function joinState_(rowsBySku) {
  var st = readAll_(SH.STATE);
  var bySku = {};
  st.forEach(function(r){
    bySku[String(r['SKU'])] = {
      inventoryHealth: String(r['在庫健全性'] || ''),
      recommendedOrderQty: num_(r['推奨発注数']),
      demandForecast: num_(r['需要予測']),
      stateUpdatedAt: r['更新日'] || ''
    };
  });
  rowsBySku.forEach(function(x){
    var s = bySku[x.sku] || {};
    x.inventoryHealth = s.inventoryHealth || null;
    x.recommendedOrderQty = s.recommendedOrderQty || 0;
    x.demandForecast = s.demandForecast || 0;
    x.stateUpdatedAt = s.stateUpdatedAt || null;
  });
  return rowsBySku;
}
```

### `src/handlers/dashboard.js`

```javascript
function handleDashboard_(e) {
  var p = normalizeParams_(e.parameter || {});
  var key = 'dash:' + p.from + ':' + p.to;
  var hit = cacheGet_(key);
  if (hit) return json_(JSON.parse(hit));
  var kpi = readDashboard_(p.from, p.to);
  var out = { kpi: kpi, series: {} }; // seriesは必要に応じて追加
  cachePut_(key, JSON.stringify(out), 120);
  return json_(out);
}
```

### `src/handlers/products.js`（一覧・詳細の最小イメージ）

```javascript
function handleProducts_(e) {
  var p = normalizeParams_(e.parameter || {});
  var sales = readAll_('商品別日次売上集計')
    .filter(function(r){ return (r['売上日']>=p.from && r['売上日']<=p.to); });

  var agg = {}; // SKU単位に集計
  sales.forEach(function(r){
    var sku = String(r['SKU'] || '');
    if (!agg[sku]) agg[sku] = { sku: sku, units:0, revenue:0 };
    agg[sku].units   += num_(r['販売数量']);
    agg[sku].revenue += num_(r['実質売上']);
  });

  var rows = Object.keys(agg).map(function(k){ return agg[k]; });
  joinMaster_(rows);
  joinState_(rows);

  // 在庫末日の在庫数を付与
  var stock = readAll_('商品別在庫日次集計').filter(function(r){ return r['日付']===p.to; });
  var stockMap = {};
  stock.forEach(function(r){ stockMap[String(r['SKU'])] = num_(r['在庫数']); });
  rows.forEach(function(x){ x.stock = stockMap[x.sku] || 0; });

  return json_({ items: rows });
}

function handleProductBySku_(e) {
  var p = normalizeParams_(e.parameter || {});
  if (!p.sku) return json_({ error: 'sku required' }, 400);

  var sku = p.sku;
  var sales = readAll_('商品別日次売上集計').filter(function(r){ return String(r['SKU'])===sku && (r['売上日']>=p.from && r['売上日']<=p.to); });
  var stock = readAll_('商品別在庫日次集計').filter(function(r){ return String(r['SKU'])===sku && (r['日付']>=p.from && r['日付']<=p.to); });

  var head = { sku: sku, units:0, revenue:0 };
  sales.forEach(function(r){ head.units+=num_(r['販売数量']); head.revenue+=num_(r['実質売上']); });
  var rows = [head];
  joinMaster_(rows);
  joinState_(rows);
  var out = {
    sku: sku, name: rows[0].name, asin: rows[0].asin, category: rows[0].category,
    kpis: {
      units: head.units, revenue: head.revenue,
      recommendedOrderQty: rows[0].recommendedOrderQty,
      demandForecast: rows[0].demandForecast
    },
    series: {
      revenueDaily: sales.map(function(r){ return { date: r['売上日'], value: num_(r['実質売上']) }; }),
      unitsDaily:   sales.map(function(r){ return { date: r['売上日'], value: num_(r['販売数量']) }; }),
      stockDaily:   stock.map(function(r){ return { date: r['日付'],  value: num_(r['在庫数']) }; })
    }
  };
  return json_(out);
}

function handleAlerts_(e) {
  // 例：推奨発注数 > 0 をActionに
  var st = readAll_('商品状態');
  var items = st.filter(function(r){ return num_(r['推奨発注数'])>0; }).map(function(r){
    return {
      sku: String(r['SKU']),
      recommendedOrderQty: num_(r['推奨発注数']),
      demandForecast: num_(r['需要予測']),
      inventoryHealth: String(r['在庫健全性'] || '')
    };
  });
  return json_({ items: items });
}
```

> これで**推奨発注数・需要予測**が**Dashboard / 一覧 / 詳細 / Alerts**に反映されます。

---

# 4. Next.js（apps/web）側（閲覧制限＆プロキシ）

## 環境変数（`.env.local`）

```env
# GAS Web AppのデプロイURL（/exec）
GAS_API_BASE="https://script.google.com/macros/s/AKfycb.../exec"
# GASのAPP_TOKEN（Script Propertiesに設定したもの）
GAS_API_KEY="super-secret-long-token"
# NextAuth / Google認証（プロジェクト側で発行）
GOOGLE_CLIENT_ID="..."
GOOGLE_CLIENT_SECRET="..."
NEXTAUTH_SECRET="..."
# UI許可ユーザー（カンマ区切り）
ALLOWED_EMAILS="you@example.com, teammate@example.com"
REVALIDATE_SECRET="revalidate-xxxx"
```

## Allowlist & ミドルウェア（概念）

* **Auth.js(NextAuth) のGoogleProvider**でログイン必須
* `middleware.ts`で**未ログイン→/api/auth/signin**に誘導
* セッションの`user.email`が`ALLOWED_EMAILS`に無ければ**403**

## GASプロキシ（サーバルート例：/app/api/gas/dashboard/route.ts）

```ts
import { NextRequest, NextResponse } from "next/server";

export async function GET(req: NextRequest) {
  const base = process.env.GAS_API_BASE!;
  const key  = process.env.GAS_API_KEY!;
  const from = req.nextUrl.searchParams.get('from') ?? '';
  const to   = req.nextUrl.searchParams.get('to') ?? '';
  const grain= req.nextUrl.searchParams.get('grain') ?? 'day';

  const url = new URL(base);
  url.searchParams.set('path','dashboard');
  url.searchParams.set('key', key);         // ← クライアントには見えない
  if (from) url.searchParams.set('from', from);
  if (to)   url.searchParams.set('to', to);
  url.searchParams.set('grain', grain);

  const res = await fetch(url.toString(), { cache: 'no-store' });
  const data = await res.json();
  return NextResponse.json(data);
}
```

> フロント（ブラウザ）は **`/api/gas/...`** を叩くだけ。**GAS鍵は漏れない**。

---

# 5. キャッシュ・更新

* **GAS**：`CacheService`（例：120秒）で軽い応答に。
* **Next**：ページはISR（例：30分）、クライアントSWR（60秒）で体感鮮度担保。
* **即時反映**：GASトリガー完了時に、Vercelの`/api/revalidate?secret=...&path=/dashboard`を叩く。

---

# 6. セキュリティまとめ（要件に沿った現実解）

* **外部は基本閲覧不可**

  * UIは**Googleログイン必須**＋**allowlist**で弾く。
  * GASは**API鍵必須**で、**Nextサーバ経由以外はアクセス不可**（URL漏洩しても鍵が無いとダメ）。
* **ドメイン運用へ拡張**（任意）

  * もしWorkspaceドメインで「社内のみ」運用にしたいときは、Web Appを「ドメイン内のみ」に変更。
  * その場合は**Nextサーバ→GAS**が通らないことがあるため、**ブラウザ→GAS**直を使うか、**GCPプロキシ**導入を検討。

---

# 7. デプロイ手順

## 初回

```bash
# GAS
pnpm -C apps/gas clasp:login
# スクリプト作成（Web App）
cd apps/gas && clasp create --type webapp --title "Seller API"
# Script Properties に APP_TOKEN=... を設定
# appsscript.json の access/executeAs を設定、必要シートIDを sheets.js に記入

# デプロイ
pnpm deploy:gas:dev

# Next（Vercelに環境変数を設定）
pnpm -C apps/web dev
pnpm deploy:web
```

## 本番

```bash
pnpm deploy:gas:prod
pnpm deploy:web
```

---

# 8. 実装ロードマップ（最短）

* **Day 1**：モノレポ雛形、GAS Code.js/handlers/sheets/utilの雛形作成、`/dashboard` API動作。
* **Day 2**：`/products` `/product` `/alerts` 実装（推奨発注数・需要予測のJOIN）。
* **Day 3**：Next Auth（Google）+ allowlist、GASプロキシ（dashboard/products/product/alerts）。
* **Day 4**：UI（Dashboard/一覧/詳細/Alerts）MVP、色分け＆バッジ。
* **Day 5**：キャッシュ（CacheService/ISR/SWR）、revalidate導線、境界ケース対応。

---

# 9. 重要な運用ルール

* GASの**列名**が変わると壊れるので、変更時は `sheets.js` のマッピングを更新。
* GAS鍵（APP_TOKEN）は**Script Properties**のみで管理。**Gitに置かない**。
* UIの許可メールは `.env` の `ALLOWED_EMAILS` に。**PR時に見直す**。
* 変更は**/apps/gas**と**/apps/web**の両方に影響しやすいので、**小さくデプロイ**。

---

これで、**TypeScriptなし・最小工数のGAS**と、**確実に外部遮断できるUI**の構成になります。
必要なら、この仕様どおりの**初期ファイル一式（雛形コードをフル）**をすぐ出します。どの画面（Dashboard/一覧/詳細/Alerts）から着手しますか？
